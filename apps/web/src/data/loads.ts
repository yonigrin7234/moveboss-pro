import { z } from 'zod';
import { createClient } from '@/lib/supabase-server';
import { computeAndSaveLoadFinancials } from './load-financials';

// Enums
export const loadStatusSchema = z.enum(['pending', 'assigned', 'in_transit', 'delivered', 'canceled']);
export const serviceTypeSchema = z.enum([
  'hhg_local',
  'hhg_long_distance',
  'commercial',
  'storage_in',
  'storage_out',
  'freight',
  'other',
]);

export const loadTypeSchema = z.enum(['company_load', 'live_load']);
export const loadSourceSchema = z.enum(['own_customer', 'partner', 'marketplace']);

/**
 * LoadFlowType indicates how a load was created/originated.
 * This is a NEW dimension, NOT a replacement for load_type, posting_type, or load_subtype.
 *
 * Used to control wizard step visibility:
 * - 'hhg_originated': Moving company created job for own customer → shows all steps
 * - 'storage_out_rfd': RFD from storage → skips Pickup step (origin is storage location)
 * - 'marketplace_purchase': Carrier bought from marketplace → skips Pickup step
 * - 'carrier_intake': Carrier manually intakes job from another company → skips Pickup step
 * - null: Legacy loads → shows all steps (backward compatible)
 */
export const loadFlowTypeSchema = z.enum([
  'hhg_originated',
  'storage_out_rfd',
  'marketplace_purchase',
  'carrier_intake',
]);

// Helper schemas
const optionalDateSchema = z
  .string()
  .optional()
  .refine((val) => !val || !Number.isNaN(Date.parse(val)), { message: 'Invalid date' });

const optionalTrimmedString = (max = 200) =>
  z
    .string()
    .trim()
    .max(max)
    .optional()
    .transform((val) => (val && val.length > 0 ? val : undefined));

// Schemas
export const newLoadInputSchema = z
  .object({
    load_type: loadTypeSchema,
    load_source: loadSourceSchema.optional(),
    load_flow_type: loadFlowTypeSchema.optional(),
    load_number: optionalTrimmedString(100), // Auto-generated by database if not provided (LD-000001 format)
    internal_reference: optionalTrimmedString(100), // User's internal CRM/job reference number
    marketplace_listed: z.boolean().optional().default(false),
    service_type: serviceTypeSchema,
    company_id: z.string().uuid().optional(), // Required for partner loads only
    // Customer details for own_customer loads
    customer_name: optionalTrimmedString(200),
    customer_phone: optionalTrimmedString(50),
    delivery_address_full: optionalTrimmedString(500),
    balance_due: z.coerce.number().nonnegative().optional(),
    assigned_driver_id: z.string().uuid().optional(),
    assigned_truck_id: z.string().uuid().optional(),
    assigned_trailer_id: z.string().uuid().optional(),

    pickup_date: optionalDateSchema,
    pickup_window_start: z.string().optional().refine((val) => !val || !Number.isNaN(Date.parse(val)), {
      message: 'Invalid datetime',
    }),
    pickup_window_end: z.string().optional().refine((val) => !val || !Number.isNaN(Date.parse(val)), {
      message: 'Invalid datetime',
    }),
    pickup_address_line1: optionalTrimmedString(200),
    pickup_address_line2: optionalTrimmedString(200),
    pickup_city: optionalTrimmedString(100),
    pickup_state: optionalTrimmedString(50),
    pickup_postal_code: optionalTrimmedString(20),
    pickup_country: z.string().trim().max(50).optional().default('US'),
    pickup_contact_name: optionalTrimmedString(200),
    pickup_contact_phone: optionalTrimmedString(50),

    dropoff_postal_code: optionalTrimmedString(20), // Required for partner loads
    dropoff_city: optionalTrimmedString(100), // Required for partner loads
    dropoff_state: optionalTrimmedString(50), // Required for partner loads
    dropoff_address_line1: optionalTrimmedString(200),
    dropoff_address_line2: optionalTrimmedString(200),

    loading_contact_name: optionalTrimmedString(200),
    loading_contact_phone: optionalTrimmedString(50),
    loading_contact_email: optionalTrimmedString(200),
    loading_address_line1: optionalTrimmedString(200),
    loading_address_line2: optionalTrimmedString(200),
    loading_city: optionalTrimmedString(100),
    loading_state: optionalTrimmedString(50),
    loading_postal_code: optionalTrimmedString(20),

    delivery_date: optionalDateSchema,
    delivery_window_start: z.string().optional().refine((val) => !val || !Number.isNaN(Date.parse(val)), {
      message: 'Invalid datetime',
    }),
    delivery_window_end: z.string().optional().refine((val) => !val || !Number.isNaN(Date.parse(val)), {
      message: 'Invalid datetime',
    }),
    delivery_address_line1: optionalTrimmedString(200),
    delivery_address_line2: optionalTrimmedString(200),
    delivery_city: optionalTrimmedString(100),
    delivery_state: optionalTrimmedString(50),
    delivery_postal_code: optionalTrimmedString(20),
    delivery_country: z.string().trim().max(50).optional().default('US'),

    cubic_feet: z.coerce.number().positive().optional(), // Required for partner loads
    rate_per_cuft: z.coerce.number().positive().optional(), // Required for partner loads
    cubic_feet_estimate: z.coerce.number().int().min(0).optional(),
    weight_lbs_estimate: z.coerce.number().int().min(0).optional(),
    pieces_count: z.coerce.number().int().min(0).optional(),
    description: optionalTrimmedString(5000),

    linehaul_rate: z.coerce.number().nonnegative().optional(),
    packing_rate: z.coerce.number().nonnegative().optional(),
    materials_rate: z.coerce.number().nonnegative().optional(),
    accessorials_rate: z.coerce.number().nonnegative().optional(),
    total_rate: z.coerce.number().nonnegative().optional(),
    status: loadStatusSchema.optional().default('pending'),
    notes: optionalTrimmedString(5000),
    // Contract/settlement fields
    actual_cuft_loaded: z.coerce.number().positive().optional(),
    contract_rate_per_cuft: z.coerce.number().positive().optional(),
    contract_accessorials_total: z.coerce.number().nonnegative().optional(),
    contract_accessorials_shuttle: z.coerce.number().nonnegative().optional(),
    contract_accessorials_stairs: z.coerce.number().nonnegative().optional(),
    contract_accessorials_long_carry: z.coerce.number().nonnegative().optional(),
    contract_accessorials_bulky: z.coerce.number().nonnegative().optional(),
    contract_accessorials_packing: z.coerce.number().nonnegative().optional(),
    contract_accessorials_other: z.coerce.number().nonnegative().optional(),
    balance_due_on_delivery: z.coerce.number().nonnegative().optional(),
    // Calculated financial fields
    base_revenue: z.coerce.number().nonnegative().optional(),
    total_revenue: z.coerce.number().nonnegative().optional(),
    company_owes: z.coerce.number().optional(), // Can be negative
    // Dispatch contact
    dispatch_contact_name: optionalTrimmedString(200),
    dispatch_contact_phone: optionalTrimmedString(50),
    amount_collected_on_delivery: z.coerce.number().nonnegative().optional(),
    amount_paid_directly_to_company: z.coerce.number().nonnegative().optional(),
    extra_accessorials_total: z.coerce.number().nonnegative().optional(),
    contract_notes: optionalTrimmedString(5000),
    origin_arrival_at: z.string().optional(),
    destination_arrival_at: z.string().optional(),
    contract_photo_url: optionalTrimmedString(2000),
    load_report_photo_url: optionalTrimmedString(2000),
    delivery_report_photo_url: optionalTrimmedString(2000),
    delivery_photos: z.array(z.string()).optional(),
    load_status: z.enum(['pending','accepted','loading','loaded','in_transit','delivered','storage_completed']).optional(),
    payment_method: z.enum(['cash','card','certified_check','customer_paid_directly_to_company']).optional(),
    payment_method_notes: optionalTrimmedString(1000),
    extra_shuttle: z.coerce.number().nonnegative().optional(),
    extra_stairs: z.coerce.number().nonnegative().optional(),
    extra_long_carry: z.coerce.number().nonnegative().optional(),
    extra_packing: z.coerce.number().nonnegative().optional(),
    extra_bulky: z.coerce.number().nonnegative().optional(),
    extra_other: z.coerce.number().nonnegative().optional(),
    storage_drop: z.boolean().optional(),
    storage_location_name: optionalTrimmedString(500),
    storage_location_address: optionalTrimmedString(500),
    storage_unit_number: optionalTrimmedString(200),
    storage_move_in_fee: z.coerce.number().nonnegative().optional(),
    storage_daily_fee: z.coerce.number().nonnegative().optional(),
    storage_days_billed: z.coerce.number().int().nonnegative().optional(),
    storage_notes: optionalTrimmedString(1000),
    company_approved_exception_delivery: z.boolean().optional(),
  })
  .superRefine((data, ctx) => {
    // Validation based on load_source
    if (data.load_source === 'own_customer') {
      // Own customer loads require customer details
      const ownCustomerRequired: Array<[keyof typeof data, string]> = [
        ['customer_name', 'Customer name is required'],
        ['customer_phone', 'Customer phone is required'],
        ['delivery_address_full', 'Delivery address is required'],
        ['balance_due', 'Balance due is required'],
      ];
      ownCustomerRequired.forEach(([field, message]) => {
        if (data[field] === undefined || data[field] === null || data[field] === '') {
          ctx.addIssue({ code: 'custom', message, path: [field] });
        }
      });
    } else if (data.load_source === 'partner') {
      // Partner loads require company and destination
      const partnerRequired: Array<[keyof typeof data, string]> = [
        ['company_id', 'Partner company is required'],
        ['dropoff_postal_code', 'Destination ZIP is required'],
        ['dropoff_city', 'Destination city is required'],
        ['dropoff_state', 'Destination state is required'],
        ['cubic_feet', 'Cubic feet is required'],
        ['rate_per_cuft', 'Rate per cubic foot is required'],
      ];
      partnerRequired.forEach(([field, message]) => {
        if (data[field] === undefined || data[field] === null || data[field] === '') {
          ctx.addIssue({ code: 'custom', message, path: [field] });
        }
      });

      // Additional validation based on load_type for partner loads
      if (data.load_type === 'live_load') {
        const liveRequired: Array<[keyof typeof data, string]> = [
          ['pickup_postal_code', 'Pickup ZIP is required'],
          ['pickup_city', 'Pickup city is required'],
          ['pickup_state', 'Pickup state is required'],
          ['pickup_address_line1', 'Pickup address is required'],
          ['pickup_contact_name', 'Pickup contact name is required'],
          ['pickup_contact_phone', 'Pickup contact phone is required'],
        ];
        liveRequired.forEach(([field, message]) => {
          if (!data[field]) {
            ctx.addIssue({ code: 'custom', message, path: [field] });
          }
        });
      } else {
        // company_load type for partner requires loading contact
        const loadingRequired: Array<[keyof typeof data, string]> = [
          ['loading_contact_name', 'Loading contact name is required'],
          ['loading_contact_phone', 'Loading contact phone is required'],
          ['loading_address_line1', 'Loading address is required'],
          ['loading_city', 'Loading city is required'],
          ['loading_state', 'Loading state is required'],
          ['loading_postal_code', 'Loading postal code is required'],
        ];
        loadingRequired.forEach(([field, message]) => {
          if (!data[field]) {
            ctx.addIssue({ code: 'custom', message, path: [field] });
          }
        });
      }
    } else {
      // Fallback for existing loads without load_source (backward compatibility)
      if (data.load_type === 'live_load') {
        const liveRequired: Array<[keyof typeof data, string]> = [
          ['pickup_postal_code', 'Pickup ZIP is required'],
          ['pickup_city', 'Pickup city is required'],
          ['pickup_state', 'Pickup state is required'],
          ['pickup_address_line1', 'Pickup address is required'],
          ['pickup_contact_name', 'Pickup contact name is required'],
          ['pickup_contact_phone', 'Pickup contact phone is required'],
        ];
        liveRequired.forEach(([field, message]) => {
          if (!data[field]) {
            ctx.addIssue({ code: 'custom', message, path: [field] });
          }
        });
      } else {
        const loadingRequired: Array<[keyof typeof data, string]> = [
          ['loading_contact_name', 'Loading contact name is required'],
          ['loading_contact_phone', 'Loading contact phone is required'],
          ['loading_address_line1', 'Loading address is required'],
          ['loading_city', 'Loading city is required'],
          ['loading_state', 'Loading state is required'],
          ['loading_postal_code', 'Loading postal code is required'],
        ];
        loadingRequired.forEach(([field, message]) => {
          if (!data[field]) {
            ctx.addIssue({ code: 'custom', message, path: [field] });
          }
        });
      }
    }
  });

export const updateLoadInputSchema = newLoadInputSchema.partial();

// TypeScript types
export type LoadStatus = z.infer<typeof loadStatusSchema>;
export type ServiceType = z.infer<typeof serviceTypeSchema>;
export type LoadType = z.infer<typeof loadTypeSchema>;
export type LoadFlowType = z.infer<typeof loadFlowTypeSchema>;
export type NewLoadInput = z.infer<typeof newLoadInputSchema>;
export type UpdateLoadInput = z.infer<typeof updateLoadInputSchema>;

// Re-export wizard step helpers from client-safe module
// These are in a separate file to avoid pulling supabase-server into client components
export { type WizardStepId, getVisibleWizardSteps, isWizardStepVisible } from '@/lib/wizard-steps';

export interface Load {
  id: string;
  owner_id: string;
  created_at: string;
  updated_at: string;

  // Core load identity
  load_type: z.infer<typeof loadTypeSchema>;
  job_number: string;
  load_number: string | null;
  internal_reference: string | null;
  service_type: ServiceType;

  // Partner company
  company_id: string;

  // Assignment (optional)
  assigned_driver_id: string | null;
  assigned_truck_id: string | null;
  assigned_trailer_id: string | null;

  // Pickup details
  pickup_date: string | null;
  pickup_window_start: string | null;
  pickup_window_end: string | null;
  pickup_address_line1: string | null;
  pickup_address_line2: string | null;
  pickup_city: string | null;
  pickup_state: string | null;
  pickup_postal_code: string | null;
  pickup_country: string;
  pickup_contact_name: string | null;
  pickup_contact_phone: string | null;

  // Delivery details
  delivery_date: string | null;
  delivery_window_start: string | null;
  delivery_window_end: string | null;
  delivery_address_line1: string | null;
  delivery_address_line2: string | null;
  delivery_city: string | null;
  delivery_state: string | null;
  delivery_postal_code: string | null;
  delivery_country: string;
  dropoff_postal_code: string | null;
  dropoff_city: string | null;
  dropoff_state: string | null;
  dropoff_address_line1: string | null;
  dropoff_address_line2: string | null;

  // Loading snapshot
  loading_contact_name: string | null;
  loading_contact_phone: string | null;
  loading_contact_email: string | null;
  loading_address_line1: string | null;
  loading_address_line2: string | null;
  loading_city: string | null;
  loading_state: string | null;
  loading_postal_code: string | null;

  // Load specifics
  cubic_feet: number | null;
  rate_per_cuft: number | null;
  linehaul_amount: number | null;
  cubic_feet_estimate: number | null;
  weight_lbs_estimate: number | null;
  pieces_count: number | null;
  description: string | null;

  // Revenue
  linehaul_rate: number | null;
  packing_rate: number | null;
  materials_rate: number | null;
  accessorials_rate: number | null;
  total_rate: number | null;
  // Contract/settlement fields
  actual_cuft_loaded?: number | null;
  contract_rate_per_cuft?: number | null;
  contract_accessorials_total?: number | null;
  balance_due_on_delivery?: number | null;
  amount_collected_on_delivery?: number | null;
  amount_paid_directly_to_company?: number | null;
  extra_accessorials_total?: number | null;

  // Status
  status: LoadStatus;

  // Notes
  notes: string | null;

  // Joined data (optional, populated when fetched with joins)
  company?: { id: string; name: string } | null;
  assigned_driver?: { id: string; first_name: string; last_name: string } | null;
  assigned_truck?: { id: string; unit_number: string } | null;
  assigned_trailer?: { id: string; unit_number: string } | null;
  // Contract/settlement fields (extended)
  contract_accessorials_shuttle?: number | null;
  contract_accessorials_stairs?: number | null;
  contract_accessorials_long_carry?: number | null;
  contract_accessorials_bulky?: number | null;
  contract_accessorials_packing?: number | null;
  contract_accessorials_other?: number | null;
  // Calculated financial totals
  base_revenue?: number | null;
  total_revenue?: number | null;
  company_owes?: number | null;
  // Dispatch contact
  dispatch_contact_name?: string | null;
  dispatch_contact_phone?: string | null;
  contract_notes?: string | null;
  origin_arrival_at?: string | null;
  destination_arrival_at?: string | null;
  contract_photo_url?: string | null;
  load_report_photo_url?: string | null;
  delivery_report_photo_url?: string | null;
  delivery_photos?: string[] | null;
  load_status?: 'pending' | 'accepted' | 'loading' | 'loaded' | 'in_transit' | 'delivered' | 'storage_completed' | null;
  accepted_at?: string | null;
  loading_started_at?: string | null;
  loading_finished_at?: string | null;
  starting_cuft?: number | null;
  ending_cuft?: number | null;
  loading_start_photo?: string | null;
  loading_end_photo?: string | null;
  first_available_date?: string | null;
  payment_method?: 'cash' | 'card' | 'certified_check' | 'customer_paid_directly_to_company' | null;
  payment_method_notes?: string | null;
  extra_shuttle?: number | null;
  extra_stairs?: number | null;
  extra_long_carry?: number | null;
  extra_packing?: number | null;
  extra_bulky?: number | null;
  extra_other?: number | null;
  storage_drop?: boolean | null;
  storage_location_name?: string | null;
  storage_location_address?: string | null;
  storage_unit_number?: string | null;
  storage_move_in_fee?: number | null;
  storage_daily_fee?: number | null;
  storage_days_billed?: number | null;
  storage_notes?: string | null;
  company_approved_exception_delivery?: boolean | null;
  // Loading document photos
  loading_report_photo?: string | null;
  origin_paperwork_photos?: string[] | null;
  contract_documents?: string[] | null;
  // Delivery workflow
  delivery_started_at?: string | null;
  delivery_finished_at?: string | null;
  delivery_location_photo?: string | null;
  // Signed documents at delivery (critical for billing/compliance)
  signed_bol_photos?: string[] | null;
  signed_inventory_photos?: string[] | null;
  // Collection
  collected_amount?: number | null;
  collection_method?: 'cash' | 'check' | 'money_order' | 'card' | 'none' | null;
  delivery_notes?: string | null;
  // Customer signature
  customer_signature?: string | null;
  customer_name_printed?: string | null;
  // Marketplace posting
  marketplace_listed?: boolean | null;
  posting_status?: 'draft' | 'posted' | 'assigned' | 'in_progress' | 'completed' | 'cancelled' | null;
  posted_at?: string | null;
  posting_type?: 'live_load' | 'rfd' | 'pickup' | null;
  // Trip assignment
  trip_id?: string | null;
  // Load flow type - how the load was created (controls wizard step visibility)
  load_flow_type?: LoadFlowType | null;
}

// Filter interface
export interface LoadFilters {
  search?: string;
  status?: LoadStatus | 'all';
  companyId?: string;
}

// Helper function to normalize date values
function nullable<T>(value: T | undefined): T | null {
  return value === undefined ? null : (value as T);
}

function normalizeDate(value?: string): string | null {
  if (!value) return null;
  return new Date(value).toISOString().split('T')[0];
}

function normalizeDateTime(value?: string): string | null {
  if (!value) return null;
  return new Date(value).toISOString();
}

// Data access functions
export async function getLoadsForUser(
  userId: string,
  filters?: LoadFilters
): Promise<Load[]> {
  const supabase = await createClient();
  let query = supabase
    .from('loads')
    .select(
      `
      *,
      company:companies!loads_company_id_fkey(id, name),
      assigned_driver:drivers!loads_assigned_driver_id_fkey(id, first_name, last_name),
      assigned_truck:trucks!loads_assigned_truck_id_fkey(id, unit_number),
      assigned_trailer:trailers!loads_assigned_trailer_id_fkey(id, unit_number)
    `
    )
    .eq('owner_id', userId);

  // Apply filters - search both load_number and internal_reference
  if (filters?.search) {
    const searchTerm = `%${filters.search}%`;
    query = query.or(`load_number.ilike.${searchTerm},internal_reference.ilike.${searchTerm}`);
  }

  if (filters?.status && filters.status !== 'all') {
    query = query.eq('status', filters.status);
  }

  if (filters?.companyId) {
    query = query.eq('company_id', filters.companyId);
  }

  query = query.order('created_at', { ascending: false });

  const { data, error } = await query;

  if (error) {
    throw new Error(`Failed to fetch loads: ${error.message}`);
  }

  return (data || []) as Load[];
}

export async function getLoadStatsForUser(userId: string): Promise<{
  totalLoads: number;
  pending: number;
  inTransit: number;
  delivered: number;
}> {
  const supabase = await createClient();

  const [totalResult, pendingResult, inTransitResult, deliveredResult] = await Promise.all([
    supabase.from('loads').select('id', { count: 'exact', head: true }).eq('owner_id', userId),
    supabase
      .from('loads')
      .select('id', { count: 'exact', head: true })
      .eq('owner_id', userId)
      .eq('status', 'pending'),
    supabase
      .from('loads')
      .select('id', { count: 'exact', head: true })
      .eq('owner_id', userId)
      .eq('status', 'in_transit'),
    supabase
      .from('loads')
      .select('id', { count: 'exact', head: true })
      .eq('owner_id', userId)
      .eq('status', 'delivered'),
  ]);

  if (totalResult.error) {
    throw new Error(`Failed to count loads: ${totalResult.error.message}`);
  }
  if (pendingResult.error) {
    throw new Error(`Failed to count pending loads: ${pendingResult.error.message}`);
  }
  if (inTransitResult.error) {
    throw new Error(`Failed to count in-transit loads: ${inTransitResult.error.message}`);
  }
  if (deliveredResult.error) {
    throw new Error(`Failed to count delivered loads: ${deliveredResult.error.message}`);
  }

  return {
    totalLoads: totalResult.count || 0,
    pending: pendingResult.count || 0,
    inTransit: inTransitResult.count || 0,
    delivered: deliveredResult.count || 0,
  };
}

export async function getLoadById(id: string, userId: string): Promise<Load | null> {
  const supabase = await createClient();
  const { data, error } = await supabase
    .from('loads')
    .select(
      `
      *,
      company:companies!loads_company_id_fkey(id, name),
      assigned_driver:drivers!loads_assigned_driver_id_fkey(id, first_name, last_name),
      assigned_truck:trucks!loads_assigned_truck_id_fkey(id, unit_number),
      assigned_trailer:trailers!loads_assigned_trailer_id_fkey(id, unit_number)
    `
    )
    .eq('id', id)
    .eq('owner_id', userId)
    .single();

  if (error) {
    if (error.code === 'PGRST116') {
      return null;
    }
    throw new Error(`Failed to fetch load: ${error.message}`);
  }

  return data as Load;
}

export async function createLoad(input: NewLoadInput, userId: string): Promise<Load> {
  const supabase = await createClient();
  // Load number is auto-generated by database trigger if not provided (LD-000001 format)
  const loadNumber = input.load_number || null;

  // Verify company ownership only if a company is specified (not required for own_customer loads)
  if (input.company_id) {
    const { error: companyError } = await supabase
      .from('companies')
      .select('id')
      .eq('id', input.company_id)
      .eq('owner_id', userId)
      .eq('is_workspace_company', false)
      .single();

    if (companyError) {
      if (companyError.code === 'PGRST116') {
        throw new Error('Company not found or you do not have access to it');
      }
      throw new Error(`Failed to verify company: ${companyError.message}`);
    }
  }

  // Verify optional assignments
  if (input.assigned_driver_id) {
    const { error: driverError } = await supabase
      .from('drivers')
      .select('id')
      .eq('id', input.assigned_driver_id)
      .eq('owner_id', userId)
      .single();
    if (driverError) {
      throw new Error('Driver not found or you do not have access to it');
    }
  }

  if (input.assigned_truck_id) {
    const { error: truckError } = await supabase
      .from('trucks')
      .select('id')
      .eq('id', input.assigned_truck_id)
      .eq('owner_id', userId)
      .single();
    if (truckError) {
      throw new Error('Truck not found or you do not have access to it');
    }
  }

  if (input.assigned_trailer_id) {
    const { error: trailerError } = await supabase
      .from('trailers')
      .select('id')
      .eq('id', input.assigned_trailer_id)
      .eq('owner_id', userId)
      .single();
    if (trailerError) {
      throw new Error('Trailer not found or you do not have access to it');
    }
  }

  const isCompanyLoad = input.load_type === 'company_load';
  const isOwnCustomer = input.load_source === 'own_customer';
  const isPartnerLoad = input.load_source === 'partner' || input.load_source === 'marketplace';

  // For own_customer loads, cuft and rate are optional (estimate only)
  const cubicFeet = input.cubic_feet ? Number(input.cubic_feet) : null;
  const ratePerCuft = input.rate_per_cuft ? Number(input.rate_per_cuft) : null;
  const linehaulAmount = cubicFeet && ratePerCuft ? Number((cubicFeet * ratePerCuft).toFixed(2)) : null;
  const accessorials = Number(input.accessorials_rate ?? 0);
  const packing = Number(input.packing_rate ?? 0);
  const materials = Number(input.materials_rate ?? 0);

  const payload = {
    owner_id: userId,
    load_type: input.load_type,
    load_source: input.load_source || null,
    load_flow_type: input.load_flow_type || null,
    load_number: loadNumber,
    internal_reference: nullable(input.internal_reference),
    service_type: input.service_type,
    company_id: input.company_id || null,
    // Customer details for own_customer loads
    customer_name: isOwnCustomer ? nullable(input.customer_name) : null,
    customer_phone: isOwnCustomer ? nullable(input.customer_phone) : null,
    delivery_address_full: isOwnCustomer ? nullable(input.delivery_address_full) : null,
    balance_due: isOwnCustomer ? nullable(input.balance_due) : null,
    assigned_driver_id: nullable(input.assigned_driver_id),
    assigned_truck_id: nullable(input.assigned_truck_id),
    assigned_trailer_id: nullable(input.assigned_trailer_id),
    pickup_date: normalizeDate(input.pickup_date),
    pickup_window_start: normalizeDateTime(input.pickup_window_start),
    pickup_window_end: normalizeDateTime(input.pickup_window_end),
    pickup_address_line1: isCompanyLoad ? null : nullable(input.pickup_address_line1),
    pickup_address_line2: isCompanyLoad ? null : nullable(input.pickup_address_line2),
    pickup_city: isCompanyLoad ? null : nullable(input.pickup_city),
    pickup_state: isCompanyLoad ? null : nullable(input.pickup_state),
    pickup_postal_code: isCompanyLoad ? null : nullable(input.pickup_postal_code),
    pickup_country: input.pickup_country || 'US',
    pickup_contact_name: isCompanyLoad ? null : nullable(input.pickup_contact_name),
    pickup_contact_phone: isCompanyLoad ? null : nullable(input.pickup_contact_phone),
    delivery_date: normalizeDate(input.delivery_date),
    delivery_window_start: normalizeDateTime(input.delivery_window_start),
    delivery_window_end: normalizeDateTime(input.delivery_window_end),
    delivery_address_line1: nullable(input.dropoff_address_line1),
    delivery_address_line2: nullable(input.dropoff_address_line2),
    delivery_city: isPartnerLoad ? input.dropoff_city : null,
    delivery_state: isPartnerLoad ? input.dropoff_state : null,
    delivery_postal_code: isPartnerLoad ? input.dropoff_postal_code : null,
    delivery_country: input.delivery_country || 'US',
    dropoff_postal_code: isPartnerLoad ? input.dropoff_postal_code : null,
    dropoff_city: isPartnerLoad ? input.dropoff_city : null,
    dropoff_state: isPartnerLoad ? input.dropoff_state : null,
    dropoff_address_line1: nullable(input.dropoff_address_line1),
    dropoff_address_line2: nullable(input.dropoff_address_line2),
    loading_contact_name: isCompanyLoad && isPartnerLoad ? nullable(input.loading_contact_name) : null,
    loading_contact_phone: isCompanyLoad && isPartnerLoad ? nullable(input.loading_contact_phone) : null,
    loading_contact_email: isCompanyLoad && isPartnerLoad ? nullable(input.loading_contact_email) : null,
    loading_address_line1: isCompanyLoad && isPartnerLoad ? nullable(input.loading_address_line1) : null,
    loading_address_line2: isCompanyLoad && isPartnerLoad ? nullable(input.loading_address_line2) : null,
    loading_city: isCompanyLoad && isPartnerLoad ? nullable(input.loading_city) : null,
    loading_state: isCompanyLoad && isPartnerLoad ? nullable(input.loading_state) : null,
    loading_postal_code: isCompanyLoad && isPartnerLoad ? nullable(input.loading_postal_code) : null,
    cubic_feet_estimate: nullable(input.cubic_feet_estimate),
    weight_lbs_estimate: nullable(input.weight_lbs_estimate),
    pieces_count: nullable(input.pieces_count),
    description: nullable(input.description),
    cubic_feet: cubicFeet,
    rate_per_cuft: ratePerCuft,
    linehaul_amount: linehaulAmount,
    linehaul_rate: linehaulAmount,
    packing_rate: packing || null,
    materials_rate: materials || null,
    accessorials_rate: accessorials || null,
    total_rate: linehaulAmount ? linehaulAmount + packing + materials + accessorials : null,
    status: input.status ?? 'pending',
    notes: nullable(input.notes),
    marketplace_listed: input.marketplace_listed ?? false,
  };

  const { data, error } = await supabase
    .from('loads')
    .insert(payload)
    .select(
      `
      *,
      company:companies!loads_company_id_fkey(id, name),
      assigned_driver:drivers!loads_assigned_driver_id_fkey(id, first_name, last_name),
      assigned_truck:trucks!loads_assigned_truck_id_fkey(id, unit_number),
      assigned_trailer:trailers!loads_assigned_trailer_id_fkey(id, unit_number)
    `
    )
    .single();

  if (error) {
    if (error.code === '23505') {
      throw new Error('Load number must be unique for your account');
    }
    throw new Error(`Failed to create load: ${error.message}`);
  }

  return data as Load;
}

export async function updateLoad(
  id: string,
  input: UpdateLoadInput,
  userId: string
): Promise<Load> {
  const supabase = await createClient();

  // Verify load ownership
  const { error: loadError } = await supabase
    .from('loads')
    .select('id')
    .eq('id', id)
    .eq('owner_id', userId)
    .single();

  if (loadError) {
    if (loadError.code === 'PGRST116') {
      throw new Error('Load not found or you do not have permission to update it');
    }
    throw new Error(`Failed to verify load: ${loadError.message}`);
  }

  // Verify company ownership if updating
  if (input.company_id) {
    const { error: companyError } = await supabase
      .from('companies')
      .select('id')
      .eq('id', input.company_id)
      .eq('owner_id', userId)
      .single();
    if (companyError) {
      throw new Error('Company not found or you do not have access to it');
    }
  }

  // Verify optional assignments if updating
  if (input.assigned_driver_id !== undefined) {
    if (input.assigned_driver_id) {
      const { error: driverError } = await supabase
        .from('drivers')
        .select('id')
        .eq('id', input.assigned_driver_id)
        .eq('owner_id', userId)
        .single();
      if (driverError) {
        throw new Error('Driver not found or you do not have access to it');
      }
    }
  }

  if (input.assigned_truck_id !== undefined) {
    if (input.assigned_truck_id) {
      const { error: truckError } = await supabase
        .from('trucks')
        .select('id')
        .eq('id', input.assigned_truck_id)
        .eq('owner_id', userId)
        .single();
      if (truckError) {
        throw new Error('Truck not found or you do not have access to it');
      }
    }
  }

  if (input.assigned_trailer_id !== undefined) {
    if (input.assigned_trailer_id) {
      const { error: trailerError } = await supabase
        .from('trailers')
        .select('id')
        .eq('id', input.assigned_trailer_id)
        .eq('owner_id', userId)
        .single();
      if (trailerError) {
        throw new Error('Trailer not found or you do not have access to it');
      }
    }
  }

  const payload: Record<string, string | number | boolean | string[] | null> = {};

  if (input.load_number !== undefined) payload.load_number = input.load_number;
  if (input.internal_reference !== undefined) payload.internal_reference = nullable(input.internal_reference);
  if (input.service_type !== undefined) payload.service_type = input.service_type;
  if (input.company_id !== undefined) payload.company_id = input.company_id;
  if (input.assigned_driver_id !== undefined) payload.assigned_driver_id = nullable(input.assigned_driver_id);
  if (input.assigned_truck_id !== undefined) payload.assigned_truck_id = nullable(input.assigned_truck_id);
  if (input.assigned_trailer_id !== undefined)
    payload.assigned_trailer_id = nullable(input.assigned_trailer_id);
  if (input.pickup_date !== undefined) payload.pickup_date = normalizeDate(input.pickup_date);
  if (input.pickup_window_start !== undefined)
    payload.pickup_window_start = normalizeDateTime(input.pickup_window_start);
  if (input.pickup_window_end !== undefined)
    payload.pickup_window_end = normalizeDateTime(input.pickup_window_end);
  if (input.pickup_address_line1 !== undefined)
    payload.pickup_address_line1 = nullable(input.pickup_address_line1);
  if (input.pickup_address_line2 !== undefined)
    payload.pickup_address_line2 = nullable(input.pickup_address_line2);
  if (input.pickup_city !== undefined) payload.pickup_city = nullable(input.pickup_city);
  if (input.pickup_state !== undefined) payload.pickup_state = nullable(input.pickup_state);
  if (input.pickup_postal_code !== undefined)
    payload.pickup_postal_code = nullable(input.pickup_postal_code);
  if (input.pickup_country !== undefined) payload.pickup_country = input.pickup_country || 'US';
  if (input.delivery_date !== undefined) payload.delivery_date = normalizeDate(input.delivery_date);
  if (input.delivery_window_start !== undefined)
    payload.delivery_window_start = normalizeDateTime(input.delivery_window_start);
  if (input.delivery_window_end !== undefined)
    payload.delivery_window_end = normalizeDateTime(input.delivery_window_end);
  if (input.delivery_address_line1 !== undefined)
    payload.delivery_address_line1 = nullable(input.delivery_address_line1);
  if (input.delivery_address_line2 !== undefined)
    payload.delivery_address_line2 = nullable(input.delivery_address_line2);
  if (input.delivery_city !== undefined) payload.delivery_city = nullable(input.delivery_city);
  if (input.delivery_state !== undefined) payload.delivery_state = nullable(input.delivery_state);
  if (input.delivery_postal_code !== undefined)
    payload.delivery_postal_code = nullable(input.delivery_postal_code);
  if (input.delivery_country !== undefined) payload.delivery_country = input.delivery_country || 'US';
  if (input.cubic_feet_estimate !== undefined)
    payload.cubic_feet_estimate = nullable(input.cubic_feet_estimate);
  if (input.weight_lbs_estimate !== undefined)
    payload.weight_lbs_estimate = nullable(input.weight_lbs_estimate);
  if (input.pieces_count !== undefined) payload.pieces_count = nullable(input.pieces_count);
  if (input.description !== undefined) payload.description = nullable(input.description);
  if (input.linehaul_rate !== undefined) payload.linehaul_rate = nullable(input.linehaul_rate);
  if (input.packing_rate !== undefined) payload.packing_rate = nullable(input.packing_rate);
  if (input.materials_rate !== undefined) payload.materials_rate = nullable(input.materials_rate);
  if (input.accessorials_rate !== undefined)
    payload.accessorials_rate = nullable(input.accessorials_rate);
  if (input.total_rate !== undefined) payload.total_rate = nullable(input.total_rate);
  if (input.status !== undefined) payload.status = input.status;
  if (input.notes !== undefined) payload.notes = nullable(input.notes);
  if (input.marketplace_listed !== undefined) payload.marketplace_listed = input.marketplace_listed;
  // Contract/settlement payload mapping
  if (input.actual_cuft_loaded !== undefined) payload.actual_cuft_loaded = nullable(input.actual_cuft_loaded);
  if (input.contract_rate_per_cuft !== undefined) payload.contract_rate_per_cuft = nullable(input.contract_rate_per_cuft);
  if (input.contract_accessorials_total !== undefined)
    payload.contract_accessorials_total = nullable(input.contract_accessorials_total);
  if (input.contract_accessorials_shuttle !== undefined)
    payload.contract_accessorials_shuttle = nullable(input.contract_accessorials_shuttle);
  if (input.contract_accessorials_stairs !== undefined)
    payload.contract_accessorials_stairs = nullable(input.contract_accessorials_stairs);
  if (input.contract_accessorials_long_carry !== undefined)
    payload.contract_accessorials_long_carry = nullable(input.contract_accessorials_long_carry);
  if (input.contract_accessorials_bulky !== undefined)
    payload.contract_accessorials_bulky = nullable(input.contract_accessorials_bulky);
  if (input.contract_accessorials_packing !== undefined)
    payload.contract_accessorials_packing = nullable(input.contract_accessorials_packing);
  if (input.contract_accessorials_other !== undefined)
    payload.contract_accessorials_other = nullable(input.contract_accessorials_other);
  if (input.dispatch_contact_name !== undefined)
    payload.dispatch_contact_name = nullable(input.dispatch_contact_name);
  if (input.dispatch_contact_phone !== undefined)
    payload.dispatch_contact_phone = nullable(input.dispatch_contact_phone);
  if (input.balance_due_on_delivery !== undefined)
    payload.balance_due_on_delivery = nullable(input.balance_due_on_delivery);
  if (input.amount_collected_on_delivery !== undefined)
    payload.amount_collected_on_delivery = nullable(input.amount_collected_on_delivery);
  if (input.amount_paid_directly_to_company !== undefined)
    payload.amount_paid_directly_to_company = nullable(input.amount_paid_directly_to_company);
  if (input.extra_accessorials_total !== undefined)
    payload.extra_accessorials_total = nullable(input.extra_accessorials_total);
  if (input.contract_notes !== undefined) payload.contract_notes = nullable(input.contract_notes);
  if (input.origin_arrival_at !== undefined) payload.origin_arrival_at = normalizeDateTime(input.origin_arrival_at);
  if (input.destination_arrival_at !== undefined)
    payload.destination_arrival_at = normalizeDateTime(input.destination_arrival_at);
  if (input.contract_photo_url !== undefined) payload.contract_photo_url = nullable(input.contract_photo_url);
  if (input.load_report_photo_url !== undefined) payload.load_report_photo_url = nullable(input.load_report_photo_url);
  if (input.delivery_report_photo_url !== undefined)
    payload.delivery_report_photo_url = nullable(input.delivery_report_photo_url);
  if (input.delivery_photos !== undefined) payload.delivery_photos = input.delivery_photos ?? null;
  if (input.load_status !== undefined) payload.load_status = input.load_status ?? null;
  if (input.payment_method !== undefined) payload.payment_method = input.payment_method ?? null;
  if (input.payment_method_notes !== undefined) payload.payment_method_notes = nullable(input.payment_method_notes);
  if (input.extra_shuttle !== undefined) payload.extra_shuttle = nullable(input.extra_shuttle);
  if (input.extra_stairs !== undefined) payload.extra_stairs = nullable(input.extra_stairs);
  if (input.extra_long_carry !== undefined) payload.extra_long_carry = nullable(input.extra_long_carry);
  if (input.extra_packing !== undefined) payload.extra_packing = nullable(input.extra_packing);
  if (input.extra_bulky !== undefined) payload.extra_bulky = nullable(input.extra_bulky);
  if (input.extra_other !== undefined) payload.extra_other = nullable(input.extra_other);
  if (input.storage_drop !== undefined) payload.storage_drop = input.storage_drop;
  if (input.storage_location_name !== undefined) payload.storage_location_name = nullable(input.storage_location_name);
  if (input.storage_location_address !== undefined)
    payload.storage_location_address = nullable(input.storage_location_address);
  if (input.storage_unit_number !== undefined) payload.storage_unit_number = nullable(input.storage_unit_number);
  if (input.storage_move_in_fee !== undefined) payload.storage_move_in_fee = nullable(input.storage_move_in_fee);
  if (input.storage_daily_fee !== undefined) payload.storage_daily_fee = nullable(input.storage_daily_fee);
  if (input.storage_days_billed !== undefined) payload.storage_days_billed = nullable(input.storage_days_billed);
  if (input.storage_notes !== undefined) payload.storage_notes = nullable(input.storage_notes);
  if (input.company_approved_exception_delivery !== undefined)
    payload.company_approved_exception_delivery = input.company_approved_exception_delivery;

  const { data, error } = await supabase
    .from('loads')
    .update(payload)
    .eq('id', id)
    .eq('owner_id', userId)
    .select(
      `
      *,
      company:companies!loads_company_id_fkey(id, name),
      assigned_driver:drivers!loads_assigned_driver_id_fkey(id, first_name, last_name),
      assigned_truck:trucks!loads_assigned_truck_id_fkey(id, unit_number),
      assigned_trailer:trailers!loads_assigned_trailer_id_fkey(id, unit_number)
    `
    )
    .single();

  if (error) {
    if (error.code === 'PGRST116') {
      throw new Error('Load not found or you do not have permission to update it');
    }
    if (error.code === '23505') {
      throw new Error('Load number must be unique for your account');
    }
    throw new Error(`Failed to update load: ${error.message}`);
  }

  // Recalculate financials after update
  await computeAndSaveLoadFinancials(id, userId);

  return data as Load;
}

export async function deleteLoad(id: string, userId: string): Promise<void> {
  const supabase = await createClient();
  const { error } = await supabase.from('loads').delete().eq('id', id).eq('owner_id', userId);

  if (error) {
    throw new Error(`Failed to delete load: ${error.message}`);
  }
}
